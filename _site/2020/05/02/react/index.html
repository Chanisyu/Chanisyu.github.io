<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title> react api 搬运 &mdash; sunseekers</title><link rel="stylesheet" href="http://localhost:4000/assets/vendor/primer-css/css/primer.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/components/collection.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/components/repo-card.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/sections/repo-list.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/components/boxed-group.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/globals/common.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/globals/responsive.css" /><link rel="stylesheet" href="http://localhost:4000/assets/css/posts/index.css" /><link rel="stylesheet" href="http://localhost:4000/assets/vendor/octicons/octicons/octicons.css" /><link rel="stylesheet" href="https://mazhuang.org/rouge-themes/dist/github.css" /><link rel="canonical" href="http://localhost:4000/2020/05/02/react/" /><link rel="alternate" type="application/atom+xml" title="sunseekers" href="http://localhost:4000/feed.xml" /><link rel="shortcut icon" href="http://localhost:4000/favicon.ico" /><meta property="og:title" content="react api 搬运" /><meta name="keywords" content="react" /><meta name="og:keywords" content="react" /><meta name="description" content="react api 搬运" /><meta name="og:description" content="react api 搬运" /><meta property="og:url" content="http://localhost:4000/2020/05/02/react/" /><meta property="og:site_name" content="sunseekers" /><meta property="og:type" content="article" /><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-05-02" /> <script src="http://localhost:4000/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="http://localhost:4000/assets/js/jquery-ui.js"></script> <script src="http://localhost:4000/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1> <a href="http://localhost:4000/" title="sunseekers" ><span class="octicon octicon-mark-github"></span> sunseekers</a ></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();" > <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="首页" >首页</a > <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="分类" >分类</a > <a href="http://localhost:4000/links/" class=" site-header-nav-item" target="" title="链接" >链接</a > <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="关于" >关于</a ></nav></div></header><style> html.dark-mode, html.dark-mode img { filter: invert(1) hue-rotate(180deg); } html.dark-mode img { opacity: 0.85; } /* 关闭了深色模式，因为布局有问题 */ #darkContainer { position: fixed; bottom: 50px; left: 100px; display: flex; display: none; } #darkContainer .text { margin-right: 8px; } #darkContainer .switch-btn { user-select: none; display: inline-block; width: 50px; border: none; height: 25px; border-radius: 50px; background: rgba(0, 0, 0, 0.25); cursor: pointer; transition: all 0.2s; position: relative; outline: none; } #darkContainer .switch-btn.switch-btn-checked { background: #1890ff; } #darkContainer .switch-btn .switch-handle { height: 20px; width: 20px; background: #fff; border-radius: 50%; position: absolute; top: 2px; left: 4px; transition: all 0.2s ease-in-out; } #darkContainer .switch-btn.switch-btn-checked .switch-handle { left: calc(100% - 22px); }</style><script> let isDarkMode = localStorage.getItem('isDarkMode'); if (isDarkMode === 'true') { document.firstElementChild.classList.add('dark-mode'); } </script> <script defer> const darkContainer = document.createElement('div'); darkContainer.id = 'darkContainer'; darkContainer.innerHTML = `<span class="text">深色模式</span>`; const btnEl = document.createElement('button'); btnEl.classList.add('switch-btn'); btnEl.innerHTML = `<div class="switch-handle"></div>`; if (isDarkMode === 'true') { btnEl.classList.add('switch-btn-checked'); } btnEl.addEventListener('click', (e) => { if (btnEl.classList.contains('switch-btn-checked')) { btnEl.classList.remove('switch-btn-checked'); document.firstElementChild.classList.remove('dark-mode'); localStorage.setItem('isDarkMode', 'false'); } else { btnEl.classList.add('switch-btn-checked'); document.firstElementChild.classList.add('dark-mode'); localStorage.setItem('isDarkMode', 'true'); } }); darkContainer.append(btnEl); document.body.appendChild(darkContainer); </script></body></html><section class="collection-head small geopattern" data-pattern-id="react api 搬运" ><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">react api 搬运</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/05/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://localhost:4000/categories/#react" title="react" >react</a > </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4330 字，约 13 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths"><article class="article-content markdown-body"><h1 id="react-api-搬运"><code class="language-plaintext highlighter-rouge">react api</code> 搬运</h1><p>更适合入门 react 的学习，因为本人没有正儿八经的 react 的项目经验。 之前因为 react 太难了从入门到放弃，后来因为疫情期间参与公司 react+ts 直播项目，打酱油再次入门 react，随着公司技术转向 react 开始入门 react。</p><p>对比 <code class="language-plaintext highlighter-rouge">vue</code> ,<code class="language-plaintext highlighter-rouge">react</code> 更加接近原生的用法。长时间的 <code class="language-plaintext highlighter-rouge">vue</code> 一把嗦，都忘记原生的要怎么写了。<code class="language-plaintext highlighter-rouge">react</code> 能够在 <code class="language-plaintext highlighter-rouge">vue</code> 和 <code class="language-plaintext highlighter-rouge">js</code> 找出相似点。所以入门很简单，放弃更容易，秒秒钟的事。</p><h2 id="jsx">JSX</h2><p>写法：和写原生的 html 差不多，因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定（例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。）用到了变量就用 {} 把变量包起来。每个 JSX 元素都是调用 React.createElement() 的语法糖。</p><p>例如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const element = (
  &lt;&gt;
    &lt;h1&gt;Hello!{name}&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/&gt;
);
</code></pre></div></div><p>&lt;&gt;&lt;/&gt; 这里指的是一个空标签，因为只能有一个“根” DOM 节点，Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用</p><h2 id="元素渲染">元素渲染</h2><p>ReactDOM.render()，方法里面传入一个要渲染的元素和一个需要挂载到某一个 DOM 节点上的 id</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById('root'));
</code></pre></div></div><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。</p><p>React 应用只会调用一次 ReactDOM.render(),页面渲染之后，如果我们想要修改 ui，就需要把代码封装到有状态组件中</p><h2 id="条件处理">条件处理</h2><p>和 javascript 上面的差不多</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 三目运算
function Greeting() {
  return (
    &lt;div&gt;
    {
      isLoggedIn? &lt;UserGreeting /&gt;:&lt;GuestGreeting /&gt;
    }
    &lt;/div&gt;
  )
}
// &amp;&amp; 使用
function Greeting() {
  return (
    &lt;div&gt;
    {
      isLoggedIn&amp;&amp;isSunseekers? &lt;UserGreeting /&gt;:&lt;GuestGreeting /&gt;
    }
    &lt;/div&gt;
  )
}
</code></pre></div></div><h2 id="列表--key">列表 &amp;&amp; key</h2><p>循环用列表渲染用 map ，写法和 javascript ，和 vue 一样要指定唯一的 key。变量用 {} 包裹</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function NumberList(){
  const numbersList = []
  return (
    &lt;ul&gt;
    {
      numbersList.map(item=&gt;(
        &lt;li key={item}&gt;{item}&lt;/li&gt;
      ))
    }
    &lt;/ul&gt;
  )
}
</code></pre></div></div><h2 id="事件处理">事件处理</h2><p>和原生的 js 差不多，区别在于 React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数（是一个变量），而不是一个字符串</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre></div></div><p>给事件传参数一般通过箭头函数</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;button onClick={() =&gt; Delete(item)}&gt;Delete Row&lt;/button&gt;
</code></pre></div></div><p>还可以是 bind 的方式，我不喜欢用,我觉得箭头函数方便</p><p><a href="https://mp.weixin.qq.com/s/8KrgoeLSuZ5-p-0cDZeb8A">354- 一文吃透 React 事件机制原理</a></p><h2 id="插槽">插槽</h2><p>有些组件无法提前知晓它们子组件的具体内容，比如通用容器的展示比如说 Loading Dialog Scroll 等等，这时候我们就可以使用组合。这个就像 vue 里面的插槽一样，父组件给子组件传递一段 JSX 或者 DOM 标签</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 子组件
function FancyBorder(props) {
  return (
    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;
      {props.children} // 这里就是插槽，内容由父组件控制，由 props.children 接受到内容
    &lt;/div&gt;
  );
}
// 父组件
function WelcomeDialog() {
  return (
    &lt;FancyBorder color="blue"&gt;
    // 传递给子组件的一段内容，作为children 通过prop 传递
      &lt;h1 className="Dialog-title"&gt;
        Welcome
      &lt;/h1&gt;
      &lt;p className="Dialog-message"&gt;
        Thank you for visiting our spacecraft!
      &lt;/p&gt;
    &lt;/FancyBorder&gt;
  );
}
</code></pre></div></div><p>通过 props.children 是一种传递的方式，我还可以也是可以直接使用 props 属性进行传值的，传值的方式和是之前一样直接在组件上面传</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function App() {
  return (
    &lt;SplitPane
      left={
        &lt;Contacts /&gt; // 给子组件传递一个 left 属性，他的值是一个组件
      }
      right={
        &lt;Chat /&gt;
      } /&gt;
  );
}
</code></pre></div></div><p>enmmmmm ，这么看的话，其实就是 props 传值的类型可以是任意的，基本类型，引用类型，函数，组件</p><h2 id="函数组件">函数组件</h2><p>因为我个人在项目中习惯使用函数组件一把嗦，关于 class 组件我就不介绍了。新版中引入了 hook，让函数组件也可有有生命周期，使用起来更加方便。</p><p>函数式组件的首字母要大写，小写的函数，不会被当作组件渲染的。函数组件可以接受一个参数 props 表示传进来的数据（所有传进来的数据都用 props 包裹起来了），不限制类型，可以是函数，对象，数组…，有一个返回值，可以被 react 识别并渲染，通常是 jsx 形式。</p><p>函数组件是都决不能修改自身的 props，是一个“纯函数”，相同的输入一定是相同的输出</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Avatar(props) {
  return (
    &lt;img className="Avatar"
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;
  );
}
</code></pre></div></div><p>数据是向下流动的,不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。</p><p>如果项目是 react+ts 结合的话，可以使用 FC 类型来声明，FC 是 FunctionComponent 的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React from 'react';
/**
 * 声明Props类型
 */
export interface MyComponentProps {
  className: string;
  style: React.CSSProperties;
}
export const MyComponent:FC&lt;MyComponentProps&gt; = props=&gt;{
  return &lt;div&gt;hello react&lt;/div&gt;;
}
export const MyComponent1:FC&lt;MyComponentProps&gt; = {className,style}=&gt;{ // 参数结构
  return &lt;div&gt;hello react&lt;/div&gt;;
}
</code></pre></div></div><p>相当于</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React from 'react';
/**
 * 声明Props类型
 */
export interface MyComponentProps {
  className: string;
  style: React.CSSProperties;
}
export function MyComponent(props:MyComponentProps){
  return &lt;div&gt;hello react&lt;/div&gt;;
}
</code></pre></div></div><p>FC 类型来声明和直接用函数有什么区别呢？</p><p>In most cases it makes very little difference which syntax is used, but you may prefer the more explicit nature of React.FunctionComponent. 最后一句话，大多数情况下普通函数的形式就够了，如果想要更精准的 TypeScript 类型推断，就用 React.FC</p><p>具体使用什么，可以看个人习惯和团队代码风格。当我们直接使用 FC 无法满足需求，这时候就使用函数组件（具体的场景没遇到过</p><p><a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？</a> =&gt; 推荐看（里面详细说了 hook 陈旧值的起因和解决方案</p><p><a href="https://codesandbox.io/s/pjqnl16lm7?file=/src/ProfilePageClass.js">函数式组件与类组件在线区别 demo</a></p><p><a href="https://juejin.im/post/5cd7f2c4e51d453a7d63b715#heading-24">React 组件设计实践总结 01 - 类型检查</a></p><p>简单说就是：函数式组件捕获了渲染所使用的值，不会获取到过新的数据</p><p>在 React 中 props 是不可变(immutable)的，所以他们永远不会改变。然而，this 而且永远是可变(mutable)的。</p><p>事实上，这就是类组件 this 存在的意义。React 本身会随着时间的推移而改变，以便你可以在渲染方法以及生命周期方法中得到最新的实例</p><p>所以如果在请求已经发出的情况下我们的组件进行了重新渲染，this.props 将会改变。showMessage 方法从一个“过于新”的 props 中得到了 user。这也就是常说的闭包陈旧的问题，其实并不是闭包陈旧，而是它本身就是这样的</p><p>函数式组件中想要渲染最新的值，那就在变化的时候在执行一次一样的操作。函数式组件捕获了渲染所使用的值这种写法是对的</p><h2 id="react-组件颗粒化划分">react 组件颗粒化划分</h2><ol><li><p>设计好的 ui 进行整个页面的简单布局</p></li><li><p>根据 ui 划分组件层级</p></li><li><p>确定 ui 完整的最小颗粒化</p></li><li><p>整理好理解划分好数据流的流动方向</p></li></ol><p>代码更多地是给人看的。当你开始构建更大的组件库时，你会意识到这种代码模块化和清晰度的重要性。并且随着代码重用程度的加深，你的代码行数也会显著地减少。:)，少一行代码，就减少一个 bug 出现的可能性</p></article><div style="padding-top:20px;"><hr/><p>虽然素未谋面。却已相识很久，很微妙也很知足。在逝去的岁月里，我们在某一刻，共同经历着一样的情愫</p><p>如果喜欢我的话，我们可以互相关注，相互学习的哟！互相鼓励，你的关注是我最大的动力来源</p><p>我叫 <a href="https://github.com/sunseekers">sunseekers</a> ，本名张敏，读的电子商务专业，干着前端的工作</p></div><div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://localhost:4000" target="_blank">sunseekers</a></li><li>本文链接：<a href="http://localhost:4000/2020/05/02/react/" target="_blank">http://localhost:4000/2020/05/02/react/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></div><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="http://localhost:4000/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2020/05/02/react/', clientID: 'efc20f7ef0379b54367b', clientSecret: 'a58112205486b93eb454f60f6d9d7bcbaf37e3fa', repo: 'sunseekers.github.io', owner: 'sunseekers', admin: ['sunseekers'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="http://localhost:4000/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'http://localhost:4000/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="http://localhost:4000/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2016 <span title="sunseekers">sunseekers</span> <a href="javascript:window.scrollTo({behavior: 'smooth', top: 0})" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo({behavior: 'smooth', top: 0})" >TOP</a></li></ul><a href="https://github.com/sunseekers/sunseekers.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://localhost:4000/" title="首页" target="">首页</a></li><li> <a href="http://localhost:4000/categories/" title="分类" target="">分类</a></li><li> <a href="http://localhost:4000/links/" title="链接" target="">链接</a></li><li> <a href="http://localhost:4000/about/" title="关于" target="">关于</a></li><li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="http://localhost:4000/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
