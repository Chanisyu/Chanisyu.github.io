---
layout: post
title: JavaScript核心原理解析 学到的东西
categories: [JavaScript]
description: JavaScript
keywords: JavaScript
---

# 重建知识体系
构建前端知识体系，要知其然知其所以然

## 重新开始，忘掉之前的
JavaScript 是动态语言
###  delete 0：JavaScript中到底有什么是可以销毁的

delete 这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”：

如果它是值，则按照传统的 JavaScript 的约定返回 true；

如果它是一个引用，那么对该引用进行分析，以决定如何操作。

如果x根本不存在，delete x操作时，x首先是一个表达式，语义上是一个引用，然后去寻找该引用的result，但是x根本不存在，是找不到的。也就做不了什么，返回ture。
如果obj.x是只读的或者不可配置的，表示他是不能删除的，但是他是实实在在的引用，是可以求值得到Result的，所以返回false。表示不能删除。

obj.x => 是一个表达式，一切表达式运算的终极目的都是为了得到一个值，表达式的值，在 ECMAScript 的规范中，称为“引用”。obj.x也是一个引用，“属性存取（"."运算符）”返回一个关于“x”的引用

一个引用只是在语法层面上表达“它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系

任何表达式计算的结果（Result）要么是一个值，要么是一个引用

{} 一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是我常常将所有这类表达式称为“单值表达式”的原因，这里并没有所谓的“引用”。可以准确地说，是“非引用类型”。

所谓“引用”是可以转换为“值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为“GetValue()”的内部操作。GetValue()是从一个引用中取出值来的行为

所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。x=x的语义并不是“x 赋给 x”，而是“把值 x 赋给引用 x”


有多少个有效的element，那么就有多少个同名的（数字下标的）属性；而array.length记录着这个最大值。所以你用array.pop()或array.push()等操作，甚至直接使用array[i]都可以影响到array.length这个属性——因为这些操作内部都会处理它。但是，你用delete去根本不会处理这个属性——因为delete是把array[i]当一个一般属性处理的，根本不知道array.length的存在。

所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。如果x的值是1，那么y = x的话，就是把1这个值“抄写”到y里面去。这是“正常的值”的处理方法，但是如果“字符串值”也这么处理，就完蛋了，因为字符串可能无数多个字符，那么当`y = x`按照“正常的值处理方法”来实现的话，这个“值的复制”的开销就受不了。

所以：
1. “值类型中的字符串”，是指照
2. “引用来赋值和传递引用”的；且，
3. 它是只传递引用（而不是传递值）的。

学到了：“引用/值”在ECMAScript规范类型中的使用与理解 。所谓的引用也是一个值（指针），指向存放变量的空间地址。

### var x = y = 100 和引用类型的关系
JavaScript 只有变量和常量两种标识符，（变量：let  var function class 常量：const import 还有特殊的for (var|let|const x …)，try … catch (x)

都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符；标识符对应的变量 / 常量“一定”会在用户代码执行前就已经被创建在作用域中。这个标题中的var x就是一个声明。在这个声明的后半部分，使用“=”这个符号引导了一个初始化语法——通常情况下可以将它理解为一个赋值运算。

JavaScript 是允许访问还没有绑定值的var所声明的标识符的。这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值，而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符

如果你向一个不存在的变量名赋值，那么 JavaScript 会在全局范围内创建它。，也就是所谓的“变量泄漏”问题

由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，

我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性

x 和 y 是两个不同的东西，前者是声明的名字，后者是一个赋值过程可能创建的变量名

变量“y”会因为赋值操作而导致 JavaScript 引擎“意外”创建一个全局变量

声明和语句的区别在于发生的时间点不同，声明发生在编译期，语句发生在运行期。声明发生在编译期，由编译器为所声明的变量在相应的变量表，增加一个名字。语句是要在运行时执行的程序代码。因此，如果声明不带初始化，那么可以完全由编译器完成，不会产生运行时执行的代码。

### a.x = a = {n:2}
如果说在语法“var x = 100”中，“= 100”是向 x 绑定值，那么“var x”就是单纯的标识符声明。这意味着非常重要的一点——“x”只是一个表达名字的、静态语法分析期作为标识符来理解的字面文本，而不是一个表达式

在“var 声明”语法中，变量名位置上就是写不成a.x的。
var a.x = ...   // <- 这里将导致语法出错


a.x = a = {n:2}

a.x总是最先被计算求值的（从左至右,优先级高）

所谓“a.x”也是一个表达式，其结果是一个“引用”。

这个表达式“a.x”本身也要再计算它的左操作数，也就是“a”。完整地讲，“a.x”这个表达式的语义是：

计算单值表达式a，得到a的引用；

将右侧的名字x理解为一个标识符，并作为“.”运算的右操作数；

计算“a.x”表达式的结果（Result）

保存在“a.x”这个引用中的“a”是当前的“{n:1}”这个对象。好的，接下来再继续往下执行：

a = {n:2}

左操作数a作为一个引用被覆盖了，这个引用仍然是当前上下文中的那个变量a。因此，这里真实地发生了一次a = {n:2}。

那么现在，表达式最开始被保留在“一个结果（Result）”中的引用a会更新吗？不会的。这是因为那是一个“运算结果（Result）”，这个结果有且仅有引擎知道，它现在是一个引擎才理解的“引用（规范对象）”，对于它的可能操作只有：取值或置值（GetValue/PutValue），以及作为一个引用向别的地方传递等。

那标题中的这行代码的最终结果是什么呢？答案是：

有一个新的a产生，它覆盖了原始的变量a，它的值是{n:2}；

最左侧的“a.x”的计算结果中的“原始的变量a”在引用传递的过程中丢失了，且“a.x”被同时丢弃。

###  export default function() {}：你无法导出一个匿名函数表达式
ECMAScript 6 模块是静态装配的，而传统的 Node.js 模块却是动态加载的

“export 如何导出名字”。这个问题的关键之处在于，如果只是导出一个名字，那么它其实在“某个名字表”中做一个登记项就可以了。并且 JavaScript 中也的确是这样处理的。但是实际使用的时候，这个名字还是要绑定一个具体的值才是可以使用的。因此，一个 export 也必须理解为这样两个步骤：

导出一个名字

为上述名字绑定一个值

在导出的时候，其实是先在“某个名字表”中登记一个“名字 x”就可以了。这个过程也就是 JavaScript 在模块装载之前对 export 所做的全部工作,

JavaScript 就可以依据所有它能在静态文本中发现的import语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载之。

所以关键的是，在“模块 export/import”语法中 ，JavaScript 是依赖 import 来形成依赖树的，与 export 无关。但是直到目前为止（我的意思是直到找到所有导入和导出的名字），没有任何一行用户的 JavaScript 代码是被执行过的。至于原因，从本讲的最开始我就讲过了：这个 export/import 过程中，源代码只被理解为静态的、没有逻辑的“代码文本”。那么既然“没有逻辑”，又怎么可能执行类似于中的
`export default <expression>;`“expression”呢？要知道所谓表达式，就是程序的计算逻辑啊。所以，这里先得出了第一个关键结论：在处理 export/import 语句的全程，没有表达式被执行！

后续的装配过程，找到并遍历模块依赖树的所有模块（这个树是排序的），然后执行这些模块最顶层的代码。直到所有模块的顶层代码都执行完毕，那么所有的导出名字和它们的值也都必然是绑定完成了的

所谓模块的装配过程，就是执行一次顶层代码而已。

找到并遍历模块依赖树的所有模块（这个树是排序的），然后执行这些模块最顶层的代码

导出名字与导出值本质上并没有差异，在静态装配的阶段，它们都只是表达为一个名字而已。

export ...语句通常是按它的词法声明来创建的标识符的，例如export var x = ...就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在import语句所在的模块中却是一个常量，因此总是不可写的=>
B模块中export一个let变量，然后在A模块中import它为x。然后你尝试在A模块中x++，你会发现提示为常量不可写。

所以A、B两个模块中的名字其实并不是同一个变量，它们名字相同（或者不同），但A模块中只是通过一个（类似于别名的）映射来指向B模块中的名字.

如果是引用类型的话因为引用的是同一个地址。所以是可以修改的（大致是这个意思，但是不准确

=> 明白了为啥 export 是静态装配的，要在代码的顶端使用，静态语法 => 在执行前完成一次操作 

### for (let x of [1,2,3]) 内部实现
越少作用域的执行环境调度效率也就越高，执行时的性能也就越好

switch语句被设计为有且仅有一个作用域，无论它有多少个 case 语句，其实都是运行在一个块级作用域环境中的，所以在case 里面声明的let/const 变量，只能在当前一个case里面访问

所谓的“块级作用域”有两种形式，一种是静态的词法作用域，这对于上面的 for 语句来说，它们都只有两个块级作用域。但是对于另一种动态的、“块级作用域”的实例来说，这答案就真的是“说不准”了

只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们

在早期的javascript中 由于作用域只有上面两个，所以任何一个“var 声明”的标识符，要么是在函数内的，要么就是在全局的，没有例外。按照这个早期设计，如下语句中的变量x：
for (var x = ...) 里面的变量i被提升到了全局的作用域中

循环语句（对于支持“let/const”的 for 语句来说）“通常情况下”只支持一个块级作用域。在 JavaScript 引擎实现“支持 _let/const_ 的 for 语句”时，就在这个地方做了特殊处理：为循环体增加一个作用域。如果将 for 语句的块级作用域称为 forEnv，并将上述为循环体增加的作用域称为 loopEnv，那么 loopEnv 它的外部环境就指向 forEnv。

于是在 loopEnv 看来，变量i其实是登记在父级作用域 forEnv 中，并且 loopEnv 只能使用它作为名字“i”的一个引用。更准确地说，在 loopEnv 中访问变量i，在本质上就是通过环境链回溯来查找标识符（Resolve identifier, or Get Identifier Reference）。 形成了一个闭包。


for (let i in [1, 2])setTimeout(() => console.log(i), 1000) // 0,1
这个例子创建了一些定时器。当定时器被触发时，函数会通过它的闭包（这些闭包处于 loopEnv 的子级环境中）来回溯，并试图再次找到那个标识符i。然而，当定时器触发时，整个 for 迭代有可能都已经结束了。
这个 loopEnv 就必须是“随每次迭代变化的”。也就是说，需要为每次迭代都创建一个新的作用域副本，这称为迭代环境（iterationEnv)。因此，每次迭代在实际上都并不是运行在 loopEnv 中，而是运行在该次迭代自有的 iterationEnv 中。也就是说，在语法上这里只需要两个“块级作用域”，而实际运行时却需要为其中的第二个块级作用域创建无数个副本。

“循环与函数递归在语义上等价”。所以在事实上，上述这种 for 循环并不比使用函数递归节省开销

### x: break x; 搞懂如何在循环外使用break，方知语句执行真解

JavaScript 的执行机制包括“执行权”和“数据资源”两个部分，分别映射可计算系统中的“逻辑”与“数据”

而块级作用域（也称为词法作用域）以及其他的作用域本质上就是一帧数据，以保存执行现场的一个瞬时状态（也就是每一个执行步骤后的现场快照）。而 JavaScript 的运行环境被描述为一个后入先出的栈，这个栈顶永远就是当前“执行权”的所有者持用的那一帧数据，也就是代码活动的现场。

作用域退出，就是函数 RETURN。作用域挂起，就是执行权的转移。作用域的创建，就是一个闭包的初始化。

“离开语句”意味着清除语句所持有的一切资源，如同函数退出时回收闭包。但是，这也同样意味着“语句”中发生的一切都消失了

函数是求值，所以返回的是对该函数求值的结果（Result），该结果或是值（Value），或是结果的引用（Reference）。而语句是命令，语句执行的返回结果是该命令得以完成的状态

=> 函数执行