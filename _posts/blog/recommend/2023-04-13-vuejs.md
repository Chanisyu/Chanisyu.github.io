---
layout: post
title: Vue.js 设计与实现 读后感
categories: [文章推荐]
description: vue3
keywords:  vue3
---

前几天读《Vue.js 设计与实现》，不仅get到很多基础的知识点，还惊叹于他的实现原理

## 如何设计一个框架
框架本身就是封装了命令式代码才实现了面向用户的声明式，虚拟dom的性能是否比操作原生innerHTML好，数量很小的时候会好，如果数量多了，虚拟dom会更好，因为更新的时候innnerHTML是要销毁所有的dom，然后去新建新的dom，而虚拟dom，只需要diff变化的部门，更新必要更新的地方就好了。也就是说更新操作，虚拟dom和数量级有关，innerHTML和模板大小有关系，原生Javascript的话，可维护性太差了


从结果看

1. 给用户提供哪些产物？ 产物的格式是什么

2. 最终框架代码的体积

从开发看

1. 报错/警告信息如何展示给用户

2. 热更新

3. 没用用到的功能模块是否不打包到最终资源里面去

4. 用户的开发体验

纯运行时的框架，由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了。然而，假如我们设计的框架是纯编译时的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用

讨论了虚拟 DOM 的性能，并给出了一个公式：声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。虚拟 DOM 的意义就在于使找出差异的性能消耗最小化。我们发现，用原生 JavaScript 操作 DOM 的方法（如document.createElement）、虚拟 DOM 和 innerHTML 三者操作页面的性能，不可以简单地下定论，这与页面大小、变更部分的大小都有关系，除此之外，与创建页面还是更新页面也有关系，选择哪种更新策略，需要我们结合心智负担、可维护性等因素综合考虑。一番权衡之后，我们发现虚拟 DOM 是个还不错的选择

在前端领域，这个概念因 rollup.js 而普及。简单地说，Tree-Shaking 指的就是消除那些永远不会被执行的代码，也就是排除 dead code，现在无论是 rollup.js 还是 webpack，都支持 Tree-Shaking。想要实现 Tree-Shaking，必须满足一个条件，即模块必须是ESM（ES Module

注释代码 /*#__PURE__*/，其作用就是告诉 rollup.js，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行Tree-Shaking
该注释也不是只有 rollup.js 才能识别，webpack 以及压缩工具（如 terser）都能识别它。

组件的渲染函数。一个组件要渲染的内容是通过渲染函数来描述的



### 虚拟DOM 性能
创建时

虚拟DOM是javascript对象+diff
innerHTML就是渲染HTML字符串

更新时：

虚拟 DOM 在更新页面时只会更新必要的元素与数据变量相关，
innerHTML 需要全量更新，销毁所有旧的DOM，新建新的DOM与模板大小相关

在更新时，究竟哪种性能更优，这个就要根据实际情况看了

## 响应式
## 渲染器
## 编译器
## 组件化
内置组件
## 服务端渲染
SSR