---
layout: post
title: js 实现评分组件
categories: [功能实现]
description: js 实现评分组件
keywords: js 实现评分组件
---

# 背景
用户对某一次的服务是否满意程度，很常见的一种需求。我同事用type="range"实现了，简直太棒了，想看重点，可以直接看代码实现三

## 为什么要自己实现她
从前遇到这样的需求的时候，都是直接找插件，或者是框架，那样的话，动动手指头就可以了。so easy。。。。

可是这次不行了，整个项目我使用的是原生开发，没有引用任何的插件or框架，纯粹的css，js，html，就因为一个小小的评分的需求，我就去引入一个js或者框架的，未免有些浪费。更何况我的代码是要交给别的同事，我用框架啥的会限制对方，这并不是一个好的选择。功能并非很难，完全可以自己实现的

## 代码实现一
需求：鼠标移动到第几个星星，他前面的所有星星都高亮，若是移动到某个星星的1/2之前就是高亮半颗星星

![]({{ site.url }}/images/star.gif)

### 实现思路：

1. 每个星星都是可以点击的，星星数量不一定 => 使用 i 标签循环展示星星的数量

```
<i class="iconfont icon-star star" aria-hidden="true"></i>
```

2. 鼠标移动上去的高亮到当前的星星 => a.记录局部当前移动到第几个星星和当前星星的位置;b.前面的星星都高亮，根据当前星星的位置判断是半个还是一颗
```
let storage = undefined;  // 点击的时候记录当前点击的位置
let sign = false; // 标记当前是否是半颗星，false 不是半星，true 为半星
  stars[i].setAttribute("index", i);

  stars[i].onmousemove = function (e) {
    let currIndex = this.getAttribute("index");
    let currSign = starHalf(e.offsetX, this.offsetWidth)
    starLight(stars, currIndex, currSign)
  }
```

3. 鼠标离开的时候，查找全局的记录星星信息的位置，添加指定样式

```
stars[i].onmouseleave = function (e) {
  
  starLight(stars, storage, sign)
}
```

4. 点击的时候，把当前的位置信息记录到全局

```
stars[i].onclick = function (e) {
  storage = this.getAttribute("index");
  sign = starHalf(e.offsetX, this.offsetWidth)
}
```

5. 收工完成

```
/**
	 * 是否是半星
	 * @param {currWidth} 一个星星最左边到鼠标位置的长度
	 * @param {halfWidth} 一个星星一半的长度
	 * @return {boolean} true 是半星，false 不是半星
	 */
	function starHalf(currWidth, halfWidth) {
		return currWidth <= halfWidth / 2 ? true : false
	}

	/**
	 * 点亮星星
	 * @param {object} elem 星星数组元素
	 * @param {number} index 最多需要点亮多个星星
	 * @param {boolean} sign 是否是半星，true 是半星，false 不是半星
	 */
	function starLight(elem, index, sign) {
		for (let i = 0; i < elem.length; i++) {
			elem[i].className = i <= index ? "iconfont icon-start-copy" : "iconfont icon-star";
		}
		if (sign) {
			elem[index].className = " iconfont icon-banxing1";
		}
	}
```

[原生评分预览](https://codepen.io/qingchuang/pen/dypNyLP)
## 代码实现二
需求还是原来的需求，只是实现方式不一样了

上面的实现方式有一点点不优雅的 1个星星一个标签包裹，实现不优雅

### 整理重新实现

1. 借助 css 变量，实现一个标签包裹多个星星 => style 上面设置一个变量，背景在x轴平铺

```
  <div id="startX1" class="star-index">
    <i class="icon-star JsStar" style="--level:6" aria-hidden="true"></i>
  </div>
```

2. 记住鼠标的位置，借助另外一个背景图标 => 亮多少星星

```
  let elBox = document.querySelector('#startX1')

  let star = elBox.querySelector(".JsStar");
  let starValue = 0; // 应该高亮的星星
  // 移动高亮星星
  star.onmousemove = function (e) {
    starLight(e.target, e.offsetX)
  }
  // 记住高亮星星
  star.onclick = function (e) {
    starValue = starLight(e.target, e.offsetX)
    var eleHidden = this.parentElement.querySelector('[type="hidden"]');
    if (eleHidden) {
      eleHidden.value = starValue;

      eleHidden.dispatchEvent(new CustomEvent('change'));
    }
  }
  // 保存高亮信息
  star.onmouseleave = function (e) {
    e.target.style.setProperty('--value', starValue)
  }

/**
 * 点亮星星
 * @param {object} elem 星星数组元素
 * @param {number} step 移动的位置
 */
function starLight(elem, step) {
  // 鼠标移动的距离
  step = step / 26
  let starValue = Math.trunc(step)
  if (step < 0) {
    starValue = 0
  } else if (step - Math.trunc(step) < 0.5) {
    // 高亮一半个星星
    starValue += 0.5
  } else {
    starValue += 1
  }

  elem.style.setProperty('--value', starValue)
  return starValue
}
```
[原生评分预览方式二](https://codepen.io/qingchuang/pen/LYRymNa)

## 代码实现三
需求还是原来的需求，只是借助了js，可不可以用css实现呢

我的同事告诉了我答案，css 可以实现，就是兼容性不好使，在移动端没有可以使用

谷歌浏览器管用，火狐需要稍微改改

```
<input type="range" name="star" min="0" max="5" step="0.5">
input[type="range"]{
      -webkit-appearance: none;
      width: 100px;
      margin: 0;
      outline: 0;
  }
  input[type="range" i]::-webkit-slider-runnable-track {
      background: coral;
      height: 20px;
      -webkit-mask: url("data:image/svg+xml,%3Csvg width='12' height='11' viewBox='0 0 12 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M6 0l1.693 3.67 4.013.476L8.74 6.89l.788 3.964L6 8.88l-3.527 1.974.788-3.964L.294 4.146l4.013-.476L6 0z' fill='%23F67600'/%3E%3C/svg%3E");
      -webkit-mask-size: 20px;
      -webkit-mask-repeat: repeat-x;
  }
  input[type="range" i]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 0;
      height: 100%;
      box-shadow: 999px 0px 0px 999px #E8EAED;
  }
```

    /* 火狐 */
```
  input[type=range]{
      -webkit-mask: url("data:image/svg+xml,%3Csvg width='12' height='11' viewBox='0 0 12 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M6 0l1.693 3.67 4.013.476L8.74 6.89l.788 3.964L6 8.88l-3.527 1.974.788-3.964L.294 4.146l4.013-.476L6 0z' fill='%23F67600'/%3E%3C/svg%3E");
      -webkit-mask-size: 20px;
      -webkit-mask-repeat: repeat-x;
      height: 20px;
  }
  input[type=range]::-moz-range-track{
      background: #E8EAED;
      height: inherit;
  }
  input[type=range]::-moz-range-progress {
      background: coral;
      height: inherit;
  }
  input[type=range]::-moz-range-thumb {
      width: 0;
      opacity: 0;
  }
```
[移动端纯css实现手指移动打分](https://codepen.io/qingchuang/pen/jOMmQab)

## 总结
最开始的时候，我的思路没有理清楚，想了半天，绕了半天的弯路。后来重新理理思路，发现不难。

