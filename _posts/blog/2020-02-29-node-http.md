---
layout: post
title: node 基础之http
categories: [node]
description: node 的一些基础知识
keywords: node 基础
---

# http

关于 http 的一些代码，
writeFile

`http` 服务器是继承 `tcp` 服务器，`http` 协议是应用层协议，是基于 `TCP` 的
对请求和响应进行了包装 ，`req` 和 `res` 都是从 `socket` 来的，先监听 `socket` 的 `data` 事件，然后
等事件发生的时候，进行解析出请求头对象，在创建请求对象，在根据请求对象创建响应对象

```
let http = require("http")
let url = require('url') // 对url进行解析
// req 流对象，是可读流
// res 是一个可写流 write
// 发消息的时候不等于和客户端连接，连接是一个长连接

// let server = http.createServer((req,res)=>{

// }).listen(8080,()=>{
//   console.log('server starts at http://localhost:8080');
// }) 等价于下面

let server = http.createServer()

// 当客户端连接上服务器之后执行回调
server.on('connection', socket => {
  socket.on('end', () => {
    console.log('连接关闭');
  })
  socket.on('close', () => {
    console.log('连接真的关闭');
  })
})

// 服务器监听客户端的请求，当有请求到来的时候执行回调
/**
 * 请求参数 req
> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.54.0
> Accept: *
*/

// req 代表客户端的连接，server 服务器把客户端的请求信息进行解析，然后放在 req 上面
// res 代表响应，如果希望向客户端响应消息，需要通过 res
server.on('request', (req, res) => {
  console.log(req.method); // 获取请求方法名
  console.log(req.url); // 获取请求路径
  console.log(url.parse(req.url));
  console.log(req.headers); // 获取请求头对象
  let result = []

  req.on('data', data => { // 请求体
    result.push(data)
  })

  req.on('end', () => {
    let r = Buffer.concat(result)
    res.end(r) // 解析完之后返回给客户端
  })
})


server.on('close', (req, res) => {
  console.log('服务器已经关闭');
})

server.listen(8080, () => {
  console.log('server starts at http://localhost:8080');
})
```

## 流

当我们往可写流写数据的时候，不是会立刻写入文件的，而是会先写入缓存区，然后等缓存区写满了之后再次真正的写入文件里

加密就是一种流的转化

普通流里面放的是普通流，对象流里面放的是对象流

数据在不同的层传递，名字不一样
物理层：帧 `frame`
网络层：数据包 `package`
传输层：段 `segment`

`ip` 头服务类型普通< 音频 < 视频 < 网络 < 路由。在数据传输的时候有这个优先级
数据在传输的过程中切割了多少片，偏移量是多少，都在 `ip` 数据包的请求头里面

大文件分段传输的时候，这里用的上核心问题还是带宽不够

Ttl 数据包存活的时间，每经过一个路由器，就减 1

客户端发送数据之前，要先建立连接，三次握手
