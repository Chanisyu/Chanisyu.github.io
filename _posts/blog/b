
6：事件循环?????

ECMAScript 6 模块是静态装配的，而传统的 Node.js 模块却是动态加载的

所谓模块的装配过程，就是执行一次顶层代码而已。















16.Array.prototype.sort的排序的原理  
各浏览器的实现方式都不一样
Google Chrome	V8	插入排序和快速排序	sort 源码实现
Mozilla Firefox	SpiderMonkey	归并排序	sort 源码实现
Safari	Nitro（JavaScriptCore ）	归并排序和桶排序	sort 源码实现
Microsoft Edge 和 IE(9+)	Chakra	快速排序	sort 源码实现

去了解一下这些排序实现的原理

阻止捕获 ,看看自己写的addEventListener文章，说说vue里面的.stop那些东西
event.stopPropagation()DOM事件流

jsonp:原理
scricpt标签没有跨域的限制

vuex的使用 以及使用上遇到的问题  
如何实现一个数据共享的vuex并且是响应式的 vuex如何实现 

localStorage sessionStorage的区别
生命周期：cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
localStorage：除非被手动清除，否则将会永久保存。
sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。
存放数据大小：cookie：4KB左右
localStorage和sessionStorage：可以保存5MB的信息。
http请求：cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信
易用性：cookie：需要程序员自己封装，源生的Cookie接口不友好
localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

设置cookie
function setCookie(name, value,days) {
//三个参数，一个是cookie的名子，一个是值，最后一个是天数
var exp = new Date();    //new Date("December 31, 9998");
exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000);
document.cookie = name + "=" ;expires=" + exp.toGMTString();
}
读取cookie
function getCookie(name) {
//取cookies函数
var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
if (arr != null)
return unescape(arr[2]);
return null;
}
删除cookie
function delCookie(name){
//删除cookie并重新演示
// 该函数检查下cookie是否设置，如果设置了则将过期时间调到过去的时间;
//剩下就交给操作系统适当时间清理cookie啦
if (getCookie(name))
{
document.cookie = name + "=" + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}
}
http长啥样？
客户端请求到服务器包括：请求行（方法，url，版本换行），请求头部（很多），空行，请求数据
服务端响应也是有四个部分组成：状态行，消息报头，空行，响应正文
`setTimeout` 支持第三个参数，一旦定时器到了，第三个参数会作为值传给第一个参数是 `function` 的里面

```
setTimeout((a)=>{
    console.log(a)
},10,'我是第三个参数')

事件循环堵塞：



宏任务/微任务
基本类型，7种null undefined string boolean number symbol bigInt
清楚浮动：父元素设置高度/父元素，ouerflow：hidden，只要能够变成BFC就可以了
http的请求方式8种
客户端路由：本质是dom元素的显示和隐藏，在a页面的时候，隐藏b页面的内容，反之毅然。路由实现
有两种方式一直是基于hash另一种是基于html的history api

JSON.parse()=> 字符串中解析出json对象
JSON.stringify()=> 从一个对象解析成字符串
浏览器缓存机制：







JavaScript的事件执行机制(宏任务，微任务)



200     //服务器成功返回网页
302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容如果选中了no cache,则请求资源时，请求头中的Cache-Control为no-cache，表明不使用缓存，则会直接获取服务器资源。另外，若没选中no cache，Cache-Control有二种情况max-age>0 时直接从游览器缓存中提取
2、max-age<=0 时向服务器发送http请求,该资源是否有修改有的话返回200 ,无的话返回304.
400     //错误请求  服务器不理解请求的语法
401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
403     //禁止  服务器拒绝请求
404     //请求的网页不存在
500     //服务器内部错误  服务器遇到错误，无法完成请求
503     //服务器不可用


封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，
让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
多用组合少用继承

## 封装
What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

##抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

##继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
Why: 解决代码复用问题。

##多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。

3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性。易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。

整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。

面向过程编程和面向过程编程语言并没有严格的官方定义。理解这两个概念最好的方式是跟面向对象编程和面向对象编程语言进行对比。相较于面向对象编程以类为组织代码的基本单元，面向过程编程则是以过程（或方法）作为组织代码的基本单元。它最主要的特点就是数据和方法相分离。相较于面向对象编程语言，面向过程编程语言最大的特点就是不支持丰富的面向对象编程特性，比如继承、多态、封装。

你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。

实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。

继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性

最小知识原则：父类方法暴露的过程中，只暴露必须要用的，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

代码风格建议
利用上下文简化命名

大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。

注释的内容主要包含这样三个方面：做什么、为什么、怎么做

善用空行分割单元块

或函数的代码行数不能太多，但也不能太少

把代码分割成更小的单元块（函数，函数单一原则）

避免函数参数过多（把参数变成一个对象或者函数拆分）

勿用函数参数来控制逻辑（违背函数单一原则）

函数设计要职责单一

移除过深的嵌套层次（if-else、switch-case、for 扁平化，参考文章）

学会使用解释性变量

分解：将要解决的问题划分成若干规模较小的同类问题。
解决：当子问题划分得足够小时，用较简单的方法解决。
合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。
