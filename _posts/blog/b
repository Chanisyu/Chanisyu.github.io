
6：事件循环?????

ECMAScript 6 模块是静态装配的，而传统的 Node.js 模块却是动态加载的

所谓模块的装配过程，就是执行一次顶层代码而已。















16.Array.prototype.sort的排序的原理  
各浏览器的实现方式都不一样
Google Chrome	V8	插入排序和快速排序	sort 源码实现
Mozilla Firefox	SpiderMonkey	归并排序	sort 源码实现
Safari	Nitro（JavaScriptCore ）	归并排序和桶排序	sort 源码实现
Microsoft Edge 和 IE(9+)	Chakra	快速排序	sort 源码实现

去了解一下这些排序实现的原理

阻止捕获 ,看看自己写的addEventListener文章，说说vue里面的.stop那些东西
event.stopPropagation()DOM事件流

jsonp:原理
scricpt标签没有跨域的限制

vuex的使用 以及使用上遇到的问题  
如何实现一个数据共享的vuex并且是响应式的 vuex如何实现 

localStorage sessionStorage的区别
生命周期：cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
localStorage：除非被手动清除，否则将会永久保存。
sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。
存放数据大小：cookie：4KB左右
localStorage和sessionStorage：可以保存5MB的信息。
http请求：cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信
易用性：cookie：需要程序员自己封装，源生的Cookie接口不友好
localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持

设置cookie
function setCookie(name, value,days) {
//三个参数，一个是cookie的名子，一个是值，最后一个是天数
var exp = new Date();    //new Date("December 31, 9998");
exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000);
document.cookie = name + "=" ;expires=" + exp.toGMTString();
}
读取cookie
function getCookie(name) {
//取cookies函数
var arr = document.cookie.match(new RegExp("(^| )" + name + "=([^;]*)(;|$)"));
if (arr != null)
return unescape(arr[2]);
return null;
}
删除cookie
function delCookie(name){
//删除cookie并重新演示
// 该函数检查下cookie是否设置，如果设置了则将过期时间调到过去的时间;
//剩下就交给操作系统适当时间清理cookie啦
if (getCookie(name))
{
document.cookie = name + "=" + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}
}
http长啥样？
客户端请求到服务器包括：请求行（方法，url，版本换行），请求头部（很多），空行，请求数据
服务端响应也是有四个部分组成：状态行，消息报头，空行，响应正文
`setTimeout` 支持第三个参数，一旦定时器到了，第三个参数会作为值传给第一个参数是 `function` 的里面

```
setTimeout((a)=>{
    console.log(a)
},10,'我是第三个参数')

事件循环堵塞：



宏任务/微任务
基本类型，7种null undefined string boolean number symbol bigInt
清楚浮动：父元素设置高度/父元素，ouerflow：hidden，只要能够变成BFC就可以了
http的请求方式8种
客户端路由：本质是dom元素的显示和隐藏，在a页面的时候，隐藏b页面的内容，反之毅然。路由实现
有两种方式一直是基于hash另一种是基于html的history api

JSON.parse()=> 字符串中解析出json对象
JSON.stringify()=> 从一个对象解析成字符串
浏览器缓存机制：







JavaScript的事件执行机制(宏任务，微任务)



200     //服务器成功返回网页
302     //临时移动  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容如果选中了no cache,则请求资源时，请求头中的Cache-Control为no-cache，表明不使用缓存，则会直接获取服务器资源。另外，若没选中no cache，Cache-Control有二种情况max-age>0 时直接从游览器缓存中提取
2、max-age<=0 时向服务器发送http请求,该资源是否有修改有的话返回200 ,无的话返回304.
400     //错误请求  服务器不理解请求的语法
401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
403     //禁止  服务器拒绝请求
404     //请求的网页不存在
500     //服务器内部错误  服务器遇到错误，无法完成请求
503     //服务器不可用