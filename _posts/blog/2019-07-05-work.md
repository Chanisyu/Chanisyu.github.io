---
layout: post
title: 解决工作bug或者需求系列文章
categories: [解决问题]
description: 解决工作问题
keywords: 解决工作问题 
---

# 说说最近开发所遇到的问题

在工作中移动端和 `PC` 端都有写。`PC` 的稍微好一点，没啥稀奇古怪的 `bug`，但是移动端就不一样了，特别是在 潜入 `IOS` 和安卓手机里面的时候。这一次我想把哪些遇到的坑都记下来

## 移动端问题

### 问题：长列表滑动的时候页面滑动不流畅（ios）
接到 `bug` 的时候我一脸懵逼，这是啥操作。同事说一句 `CSS` 代码就可以解决了 `-webkit-overflow-scrolling: touch;`; 以前都没有用过这个东西，去查这个东西的时候，发现网上很多解释。借用用 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/-webkit-overflow-scrolling) 的解释 `-webkit-overflow-scrolling` 属性控制元素在移动设备上是否使用滚动回弹效果. `touch` 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。


### 问题：ios 监听事件没法唤起软键盘，

解决关键: 用户触发，要不是直接点击文本输入元素，要不就是间接点击。参考文章
[移动端JavaScript拉起软键盘](http://www.iamaddy.net/2016/11/mobile-keyboard-javascript/)


### 问题：创建和编辑页面用到同一个 `component` 组件的时候，默认组件不会在触发 `vue` 里面的 `create` 和 `mounted` 钩子函数？(因为 `vue` 默认是高度复用)

解决方案一 ： 可以在 `router-view` 组件上面加一个唯一的 `key` 来处理，保证唯一的 `key` ,路由切换的时候就会重新触发渲染钩子
```
<router-view :key="key"></router-view>

computed: {
  key() {
    // 只要保证 key 唯一性就可以了，保证不同页面的 key 不相同
    return this.$route.fullPath
  }
 }
```

解决方法二：在当前页面使用 `watch` 监听路由是否发生变化

```
watch:{
  '$route'(newVal,oldVal){ //路由发生了编辑
    if (newVal.path == "/systemSetting/appdetails") {
    //进行数据的初始化
  }
}
},
```
解决方法三：使用 `v-if` 强制所有组件重新渲染，可以使用 [`provide`](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5) 进行依赖注册

```
<router-view v-if="isRouterAlive"></router-view>

  methods: {
    reload () {
      this.isRouterAlive = false
      this.$nextTick(() => {
        this.isRouterAlive = true
      })
    },
   }
```

解决方案都是根据路由的变化，对组件进行重新渲染或者初始化

### 问题：监听 `scrollTop` 失效，不能预期的自动滚动到浏览器底部或者顶部

解决方案[参考文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView)
### 问题 `transform: rotate(180deg)` 失效
解决： 使用元素要是 `display: block` 或者 `display:inline-block`

### 问题： `scroll` 事件会失效

没有任何问题，我在用 `vue`开发去监听 `Scroll` 事件（网上有很好的 `BetterScroll` ，开发的时候会用它，但是想自己可以知道实现原理），监听了半天没有任何用，网上给出很多的解决方案 `window.addEventListener()`，元素的 `overflow` 属性要设置为 `scroll` 都可以解决，但是不明白为啥，继续深究原来是看到了 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/scroll_event) 对 `scroll` 事件的描述: `element` 的 `scroll` 事件不冒泡, 但是 `document` 的 `defaultView` 的 `scroll` 事件冒泡；有一篇写的很不错的文章推荐[你所不知道的scroll事件：为什么scroll事件会失效？](https://ayase.moe/2018/11/20/scroll-event/) 我觉得里面写的蛮好的。借用里面的代码分析

```
<body>
  <div id="root">
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
    <p>Hello world</p>
  </div>
  <script src="scroll-in-window.js"></script>
</body>
// scroll-in-window.js

window.addEventListener('scroll', e => console.log('scroll handler is triggered in window during capture phase.'), true)
window.addEventListener('scroll', e => console.log('scroll handler is triggered in window during bubble phase.'))

const root = document.getElementById('root')
root.addEventListener('scroll', e => console.log('scroll handler is triggered in root during capture phase.'), true)
root.addEventListener('scroll', e => console.log('scroll handler is triggered in root during bubble phase.'))
```

请自行运行看效果

```
<!DOCTYPE html>
<html>

<head>
  <title>Scroll In Element</title>
  <style>
    body {
      margin: 0;
    }

    #wrapper {
      width: 100%;
      height: 100vh;
      display: flex;
      overflow: hidden;
    }

    #left-col {
      overflow: hidden;
      flex: 0 0 300px;
      background-color: aqua;
    }

    #right-col {
      flex: 1;
      overflow: auto;
    }
  </style>
</head>

<body>
  <div id="wrapper">
    <div id="left-col">
      <nav>
        barabara
      </nav>
    </div>
    <div id="right-col">
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
      <p>Hello world</p>
    </div>
  </div>
  <script src="scroll-in-element.js"></script>
</body>

</html>

const log = (elem, phase) => {
  console.log(`scroll handler is trigged in ${elem} during ${phase}`)
}

const bindEvent = (elem, elemName)  => {
  elem.addEventListener('scroll', log.bind(null, elemName, 'capture'), true)
  elem.addEventListener('scroll', log.bind(null, elemName, 'bubble'))
}

bindEvent(window, 'window')
const wrapper = document.querySelector('#wrapper')
bindEvent(wrapper, 'wrapper')
const rightCol = document.querySelector('#right-col')
bindEvent(rightCol, 'rightCol')
```

还有一篇有问题的[vue 无法监听scroll事件](https://segmentfault.com/q/1010000009119633)

###  PC 端遇到的问题

 未完待续 




