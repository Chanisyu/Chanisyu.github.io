所有一切表达式运算的终极目的都是为了得到一个值

一个引用只是在语法层面上表达“它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系

所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）

任何表达式计算的结果（Result）要么是一个值，要么是一个引用

在 JavaScript 的内部，所谓“引用”是可以转换为“值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为“GetValue()”的内部操作。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为

GetValue()是从一个引用中取出值来的行为。

x = x我们上面说过，所谓 x 其实是一个引用。上面的表达式其实是一个赋值表达式，那么“引用 x 赋值给引用 x”有什么意义呢？其实这在语法层面来解释是非常直接的：所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。那么上面的x=x，其实就是被翻译成：x = GetValue(x)

“delete x”归根到底，是在删除一个表达式的引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。

所有的“声明”：都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符；标识符对应的变量 / 常量“一定”会在用户代码执行前就已经被创建在作用域中。

类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。

他十几年的一线开发，把自己做成了熟手、熟练工，东西会得再多，技巧再熟练，也不过是卖油翁的“但手熟尔”

大多数同学都是在旧有的概念中构建新的概念集合，如同浮沙高塔，原本基础就搭得不对，你再怎么努力，也是上不了这个台阶的-> 不要这样

教而不明其法，学而不得其道=> 可以解释知道那么多道理，却依旧过不好自己的一生

追求真源才应是本性，撇去浮尘才能不被把控


语句的关键字 var/let/const 只是用来“声明”变量名 x 的，去除掉“var x”之后剩下的部分，并不是一个严格意义上的“赋值运算”，而是被称为“初始器（Initializer）”的语法组件,“=”号并不是运算符，而是一个语法分隔符号

紧随于“var/let/const”之后的，一定是变量名（标识符），且无论是一个或多个，都是在 JavaScript 语法分析阶段必须能够识别的。

学到了：变量声明语句和赋值语句不能混淆在一起，变量声明语句在静态语法分析期作为标识符来理解的字面文本
let obj={foo(){return this}}

obj.foo()===obj // true // foo在对象上面的引用
eval('obj.foo')()==obj // false 因为eval 返回的是一个结果不支持引用，所以返回foo的时候就返回了它本身

执行语句：eval('obj.foo') 返回的是值，命令式范型的体现
执行表达式： obj.foo() 可以返回的是一个引用，函数式范型的体现

那么这个列表实际上是根据形式参数的样式（Formal of Parameters），按照传入参数逐一匹配出来的。这个所谓“逐一匹配”，就是我们说的“特殊的可执行的逻辑”。任何实际参数在传入一个函数的形式参数时，都会经历这样的一个执行过程，它是“将函数实例化”这个内部行为的一个处理阶段。（把参数放在 arguments 列表中，然后让 arguments 中的值与参数表中的名字对应起来，目的是在函数内部可以访问名字

可执行结构：语句，表达式，剩余参数，参数展开，赋值模板，参数赋默认值（剩余参数唯一能动态创建和指定参数个数的语法，可以替换 foo.apply() 

参数展开其实是数组展开的一种应用，而数组展开在本质上就是依赖迭代器的。（拥有Symbol.iterator 这个符号属性有值的对象）

```

function foo({x, y}) {
  ...
}

for (var {x, y} in obj) {
  ...
}
```

而所有这些地方的赋值模板，都是在语法解析期就被分析出来，并在 JavaScript 内部作为一个可执行结构存放着。然后在运行期，会用它们来完成一个“从右操作数按模板取值，并赋值给左操作数”的过程。这与将函数的参数表作为样式（Formal）存放起来，然后在运行期逐一匹配传入值是异曲同工的。

学到了，

```

(function f() {
  ...
})=> 那么它的结果是一个函数类型的“数据”
```
说函数既是可以执行的逻辑，也同时是可以被逻辑处理的数据。回调函数

```
var arr = new Array;
for (var i=0; i<5; i++) arr.push(function f() {
  // ...
});
```
在这个例子中，静态的函数f()有且仅有一个；而在执行后，arr[]中将存在该函数f()的 5 个实例，每一个称为该函数的一个运行期的闭包。它们各各不同，例如：

> arr[0] === arr[1]
false

所以简而言之，任何时候只要用户代码引用一次这样的函数（的声明或字面量），那么它就会拿到该函数的一个闭包。注意，得到这个闭包的过程与是否调用它是无关的。

闭包的作用与实现方法都与“for 循环”中的迭代环境没有什么不同.
也就是说，命令式语句和函数式语言，是采用相同的方式来执行逻辑的。只不过前者把它叫做 _iteratorEnv_，是 _loopEnv_ 的实例；后者把它叫做闭包，是函数的实例。

函数闭包其实是在它调用的时候才创建和初始化的。——只不过，所有的、因为函数调用而产生的闭包，都是上面这个实例的一个“副本”。所以，一个实例其实也可以有多个闭包。(递归)

当函数的参数不是简单类型的时候（缺省参数、剩余参数和模板参数之一的）无论是否在严格模式中，形式参数与 arguments 之间都将解除绑定关系。

```
在旧的模式中，参数和arguments下标是绑定的，所以：

function f(x) {
  console.log(x); // input - 0
  arguments[0] = 100;
  console.log(x); // 100
  console.log(arguments[0]); // 100
}
f(0);


但是非简单类型参数是，这两个东西是不绑定的。例如：

function f(x = 'a') {
  console.log(x); // input - 0
  arguments[0] = 100;
  console.log(x); // input - 0
  console.log(arguments[0]); // updated - 100
}
f(0);
```
在使用传统的简单参数时，只需要将调用该参数时传入的实际参数与参数对象（arguments）绑定就可以了；而使用“非简单参数”时，需要通过“初始器赋值”来完成名字与值的绑定。同样，这也是导致“形式参数与 arguments 之间解除绑定关系”的原因。

这与参数的实现方法（两种绑定方式）有关，而与是不是调用时传入了缺省参数——以及其它非简单参数——是无关的。

两种绑定模式的区别在于：通常将实际参数与参数对象绑定时，只需要映射两个数组的下标即可，而“初始器赋值”需要通过名字来索引值（以实现绑定），因此一旦出现“重名参数”就无法处理了。

```
// 一般函数声明
function f(x) {
  console.log(x);
}

// 表达式`a=100`是“非惰性求值”的
f(a = 100); // 相当于f(100) 相当于是var
```
回顾这个过程，请你注意一个问题：a = 100这行表达式执行在哪个上下文环境中呢？答案是：在函数外（上例中是全局环境）。

在这里由于参数与函数体使用同一个块作用域，因此如果函数参数与函数内变量同名，那么它们事实上将是同一个变量


f = (x = x) => x; 会报错是因为在“绑定实际传入的参数”时，就需要执行一个“x = 100”的计算过程。不同于之前的f(a = 100)，在这里的表达式x = 100将执行于这个新创建的闭包中。这很好理解，左侧的“参数 x”是闭包中的一个语法组件，是初始化创建在闭包中的一个变量声明，因此只有将表达式放在这个闭包中，它才可以正确地完成计算过程。（相当于是let变量

为什么不干脆就在“初始器”创建的时候，就赋一个初值 undefined 呢？说到这里，可能你也猜到了，因为在“缺省参数”的语法设计里面，undefined 正好是一个有意义的值，它用于表明参数表指定位置上的形式参数是否有传入，所以参数 undefined 也就不能作为初值来绑定，这就导致了使用“初始器”的参数表中，所对应那些变量是一个“无初值的绑定”。