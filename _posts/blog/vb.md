所有一切表达式运算的终极目的都是为了得到一个值

一个引用只是在语法层面上表达“它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系

所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）

任何表达式计算的结果（Result）要么是一个值，要么是一个引用

在 JavaScript 的内部，所谓“引用”是可以转换为“值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为“GetValue()”的内部操作。所谓内部操作，也称为内部抽象操作（internal abstract operations），是 ECMAScript 描述一个符合规范的引擎在具体实现时应当处理的那些行为

GetValue()是从一个引用中取出值来的行为。

x = x我们上面说过，所谓 x 其实是一个引用。上面的表达式其实是一个赋值表达式，那么“引用 x 赋值给引用 x”有什么意义呢？其实这在语法层面来解释是非常直接的：所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。那么上面的x=x，其实就是被翻译成：x = GetValue(x)

“delete x”归根到底，是在删除一个表达式的引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。

所有的“声明”：都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符；标识符对应的变量 / 常量“一定”会在用户代码执行前就已经被创建在作用域中。

类的内部是处于严格模式中，它的名字是按 let 来处理的，而 import 导入的名字则是按 const 的规则来处理的。所以，所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。

当向一个不存在的变量赋值的时候，由于全局对象的属性表是可以动态添加的，因此 JavaScript 将变量名作为属性名添加给全局对象。而访问所谓全局变量时，就是访问这个全局对象的属性。因此，实际效果就变成了“可以动态地向全局环境中添加一个变量”。并且，显然地，我们在第一讲已经讲过这个结果——你可以删除掉这个动态添加的“变量”，因为本质上就是在删除全局对象的属性。

他十几年的一线开发，把自己做成了熟手、熟练工，东西会得再多，技巧再熟练，也不过是卖油翁的“但手熟尔”

大多数同学都是在旧有的概念中构建新的概念集合，如同浮沙高塔，原本基础就搭得不对，你再怎么努力，也是上不了这个台阶的-> 不要这样

教而不明其法，学而不得其道=> 可以解释知道那么多道理，却依旧过不好自己的一生

追求真源才应是本性，撇去浮尘才能不被把控