ES6提出了四大组件：Promise、类、模块、生成器/迭代器。这事实上是在并行语言、面向对象语言、结构化语言和函数式语言四个方向上的奠基工作

JavaScript的应用环境，主要由宿主环境与运行期环境构成。其中，宿主环境是指外壳程序（shell）和Web浏览器等，而运行期环境则是由JavaScript引擎内建的

在JavaScript中，“空白对象”是整个原型继承体系的根基

所谓声明，即约定数据的生存周期和逻辑的作用域

一般来说，JavaScript引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不执行；当语法分析通过时，脚本代码才会执行。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行

ECMAScript规范类型是为了实现ECMAScript语言类型而存在的

ECMAScript语言类型是为了叙述JavaScript语言的规范而存在的

如果构造器（Object）有一个原型对象（Object.prototype），则由该构造器创建的实例（obj）都必然复制自该原型对象。换言之，所谓“原型（Prototype）”，就是构造器用于生成实例的模板。而这样的“复制”就存在多种可能性，由此引申出动态绑定和静态绑定等问题（this的问题，引用切断的问题

对象的属性查找的时候规则是先找自有属性表

1. 保证优先读取对象的自有属性表，

2. 如果在上述自有属性表中没有指定属性，则尝试遍历对象的整个原型链，直到原型为空（null）或找到该属性。

[Object.getOwnPropertyDescriptor()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) 我们通常用这个方法来查找对象自有属性对应的属性描述符

[Object.getOwnPropertyNames()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames):对象的所有自身属性的属性名

存取实例中的属性，比存取原型中的属性的效率要高，因为在实例中找到了，就可以少遍历一个自有属性表

原型继承依赖程序的执行过程，是通过原型修改来实现继承特性的一种方法。在这种方法中，因为子类依赖父类的构造过程，所以子类必然晚于父类构造

对象实例是通过访问obj.constructor.prototype来访问到其原型的方法的。正是出于这个目的，维护obj.constructor的有效性才成为原型继承的一种“与生俱来”的负担


super：在类的构造方法声明中，super指向了父类构造器，this指向new创建的新实例

super.xxx作为方法调用时，将会隐式地传入当前方法中的this对象。

```
class F {
   static show(){
        console.log('我是'+super.toString())
    }
}
// undefined
F.show() // F 这个函数
```


JavaScript事实上允许用户代码通过super.xxx这一语法来引用父类中的与xxx同名的属性，而不仅仅是方法


所以只要是类，就总是显式或隐式地存在一个对应的构造方法。因此在JavaScript中，类作为标识符在实质上就是“一个引用了该构造方法的函数”

JavaScript的原型继承模型是依赖“变量作用域”，来实现封装特性的

同样由于没有严格的类型检测，因此你可以对任何对象调用任何方法，而无须考虑它是否“被设计为”拥有该方法

其构造器函数对实例的这种修饰作用—对于原型继承来说—可有可无。于是就出现了Object.create()这样一种简单的方法，它将“构造器函数”从对象创建过程中赶了出去。在这种新的机制中，对象变成了简单的“原型继承+属性定义”，而不再需要“构造器”这样一层语义


Object.create()和Object.setPrototypeOf()是ES6之后公开的两种操作原型的主要方式，它向应用层开放了对象系统的核心结构。这一方面是对旧设计的修补，例如，用来替代早期使用new维护原型链，并进一步构建对象系统的方法 

```
function MyObject(){}

Object.setPrototypeOf(MyObject.prototype,ParentClass.prototype)

或者

MyObject.prototype = Object.create(ParentClass,prototype)
```

在继承方式的选择上，仍应择需而用：其一，在大型系统上必须采用类继承的思路，其继承关系的确定性和支持静态语法检测等特性，可以帮助开发者最终简化构建大型系统的开发和业务逻辑的实现，并提供足够的系统稳定性；其二，在小型结构或者体系的局部使用原型继承的思路，既可以有优美的实现和高效的性质，也可以更深入地理解JavaScript中混合不同语言特性的精髓。

在完全不考虑“对象”如何实现与存储的情况下，仅其语义而言：对象，就是一组（零到任意多个）属性的集合，即所谓的“对象是属性包”。至于这个集合中的成员究竟是普通属性还是方法，或者是可被回调的“事件”，是无关紧要的。所以属性的性质也并不用于描述该属性的类型或作用，而主要用于描述一个属性之于这个集合的种种关系。这些关系有三种：Writable（可写）、Enumerable（可列举）和Configurable（可配置）。除此之外，一个属性本身还具有两种性质：Name/Value，即名字和值。综上所述，如果要“声明”一个对象，本质上来说就是（为它所有的属性）描述清楚上述5种性质，JavaScript约定了Writable、Enumerable和Configurable三种性质的默认值，因此多数情况下只需指定Name和Value即可。

在JavaScript中不能直接修改属性描述符的性质以影响源对象，这是因为属性描述符只是复制了对象属性的内部性质，而不是这些性质的直接引用。但是可以通过Object.defineProperty()等方法来声明（或覆盖）原有的属性描述符，从而影响对象属性的性质。这些可用的方法有三个Object.defineProperty() Object.definePropertys() Object.create()

for...in语句得到的总是该对象全部的可见属性名，而Object.keys()将得到其中的一个子集，即（不包括继承而来的）自有的可见属性名

Object.getOwnPropertyXXX()得到的与上述两种情况都不相同，它列举全部自有的属性，无论是否可见


一门语言的可用性与易用性，取决于对语法设计与语义表达之间的关系处理，语法总是能清晰无歧义地表达为一种明确的语义，以使得程序员的思维过程能被运行环境的语法分析过程以相同的语言模型表述


因为模块的使用机制约定—同一模块的多次import之间会共享同一个块（以及其环境），因此事实上它的形式分块不是由import语句来创建的，而是由JavaScript引擎在装配所有模块的过程中创建的

JavaScript约定所有的声明都必须在语法分析期处理。

类似于模板字符串、数组与对象等的初始器，它们的语法事实上都提供了在表达式级别上进行运算的能力，但它们都没有自己的词法作用域。

程序最终可以被表达为数据和逻辑（即结构和算法）两个方面

所谓动态类型声明，是指语言的变量是无类型的，只有在它们被赋值后才具有某种类型；所谓动态空间分配，是指变量在赋值时才会为其分配空间


变量可以被理解为一个无类型指针（没有类型含义的、指向自由地址的标识），只有在指针被分配一个确定的内存空间时，才可以获知该指针指向内存区的内容以及可能的数据类型。

JavaScript是解释执行的，它并不能编译成二进制文件

在值类型数据经过“包装类”包装后得到的对象与原数据将并不再是同一数据，只是二者具有等同的值而已。

JavaScript内建的Object()类支持显式地将boolean、number、string和symbol四种值类型数据包装成对应的对象
值类型中的“符号类型（symbol）”存在对应的包装类，但是它不能通过这种显式创建的语法来得到对象实例。

索引数组更加低效

然而由于JavaScript数组是“基于关联数组”实现的，因此数组并不是一个连续分配的空间，而数组的很多方法都是使用递增或递减序的循环来列举那些元素的，包括最常见的indexOf()等。因此这样的索引方法并不会真正地带来什么效率（这在其他高级语言中是更有效的，或有特殊的优化方案）。而且，当数组进一步变得更加无序、自由存取时，这种列举的效率可能会更差。例如，我们可能声明一个数组为一百万个（或更多[插图]）元素大小，但事实上却没有一个元素被存入数组—JavaScript的数组在存储特性上是即需即分配的动态数组，不会导致存储问题。因此对这种数组做上述列举，会产生大量的虚耗（类似下例的效果）

数组的成员和length属性都是动态存取的。也就是说，无论是for...of迭代，还是一般的for/while循环，在循环体内是可以增删数组成员的；而且只要这个数组成员的下标还没有被访问，那么这些动态添加的成员将是可被列举的

var x = 8,y=9
var ya=()=>console.log(this.x * this.y)
var a={x:99,y:10}
ya.call(a)

类数组对象:索引数组的独特性并不表现在整数下标存取，而在于length属性的维护。反过来说，如果一般对象有了length属性，那么它与一般数组又有什么不同呢,那她就是类数组。但是所有使用数组的迭代器接口的方法，却不适用于类数组对象，这是因为类数组对象默认时并没有定义Symbol.iterator这个属性。解决这个问题的方法也非常简单：`obj[Symbol.iterator]=Array.prototype[Symbol.iterator]` 即可


除了let/const之外的声明和模块的导入导出是在用户代码执行之前由模块的装配逻辑负责绑定的，其他都是执行不到，就不绑定

使用for...of来列举数组的值时，迭代器使用的是索引值（而不是对象属性的key），并且迭代的次数是动态访问length值的，因此它能列举数组动态添加的成员。for...in 变量的是对象的属性key，所以在一开始就定了，不能列举数组动态添加的成员